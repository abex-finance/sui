window.SIDEBAR_ITEMS = {"fn":[["execute","Execute `module::function<type_args>(object_args ++ pure_args)` as a call from `sender` with the given `gas_budget`. Execution will read from/write to the store in `state_view`. IMPORTANT NOTES on the return value: The return value is a two-layer SuiResult. The outer layer indicates whether a system error has occurred (i.e. issues with the sui system, not with user transaction). As long as there are no system issues we return Ok(SuiResult). The inner SuiResult indicates the execution result. If execution failed, we return Ok(Err), otherwise we return Ok(Ok). TODO: Do we really need the two layers?"],["generate_package_id","Given a list of `modules`, use `ctx` to generate a fresh ID for the new packages. If `is_framework` is true, then the modules can have arbitrary user-defined address, otherwise their addresses must be 0. Mutate each module’s self ID to the appropriate fresh ID and update its module handle tables to reflect the new ID’s of its dependencies. Returns the newly created package ID."],["new_move_vm",""],["new_session",""],["publish",""],["resolve_and_type_check","Check that `package_object`, `module` and `function` are validCheck that the the signature of `function` is well-typed w.r.t `type_args`, `object_args`, and `pure_args`Return the ID of the resolved module, a vector of BCS encoded arguments to pass to the VM, and a partitioning of the input objects into objects passed by value vs by mutable reference"],["store_package_and_init_modules","Store package in state_view and call module initializers"],["verify_and_link","Given a list of `modules`, links each module against its dependencies and runs each module with both the Move VM verifier and the Sui verifier."]],"struct":[["MoveVM",""],["TypeCheckSuccess",""]]};