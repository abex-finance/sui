window.SIDEBAR_ITEMS = {"attr":[["enum_dispatch","Annotating a trait or enum definition with an `#[enum_dispatch]` attribute will register it with the enum_dispatch library, allowing it to be used to generate impl blocks elsewhere."]],"constant":[["DERIVATION_PATH_COIN_TYPE",""],["DERVIATION_PATH_PURPOSE_ED25519",""],["DERVIATION_PATH_PURPOSE_SECP256K1",""],["PROOF_OF_POSSESSION_DOMAIN",""],["TEST_COMMITTEE_SIZE",""]],"enum":[["PublicKey",""],["Signature",""],["SignatureScheme",""],["SuiKeyPair","Account Keys"]],"fn":[["add_to_verification_obligation_and_verify",""],["deterministic_random_account_key",""],["generate_proof_of_possession",""],["get_account_key_pair",""],["get_authority_key_pair",""],["get_key_pair",""],["get_key_pair_from_bytes",""],["get_key_pair_from_rng","Generate a keypair from the specified RNG (useful for testing with seedable rngs)."],["random_committee_key_pairs","Generate a random committee key pairs with size of TEST_COMMITTEE_SIZE."],["random_key_pairs",""],["sha3_hash",""]],"mod":[["bcs_signable_test",""]],"struct":[["AuthorityPublicKeyBytes","Defines the compressed version of the public key that we pass around in Sui"],["AuthorityQuorumSignInfo","Represents at least a quorum (could be more) of authority signatures. STRONG_THRESHOLD indicates whether to use the quorum threshold for quorum check. When STRONG_THRESHOLD is true, the quorum is valid when the total stake is at least the quorum threshold (2f+1) of the committee; when STRONG_THRESHOLD is false, the quorum is valid when the total stake is at least the validity threshold (f+1) of the committee."],["AuthoritySignInfo",""],["ConciseAuthorityPublicKeyBytes","A wrapper around AuthorityPublicKeyBytes that provides a concise Debug impl."],["Ed25519SuiSignature",""],["EmptySignInfo",""],["Secp256k1SuiSignature",""],["Secp256r1SuiSignature",""],["VerificationObligation",""]],"trait":[["AggregateAuthenticator","Trait impl’d by aggregated signatures in asymmetric cryptography."],["Authenticator","Trait impl’d by signatures in asymmetric cryptography."],["AuthoritySignInfoTrait","AuthoritySignInfoTrait is a trait used specifically for a few structs in messages.rs to template on whether the struct is signed by an authority. We want to limit how those structs can be instanted on, hence the sealed trait. TODO: We could also add the aggregated signature as another impl of the trait. This will make CertifiedTransaction also an instance of the same struct."],["EncodeDecodeBase64","Cryptographic material with an immediate conversion to/from Base64 strings."],["KeypairTraits","Trait impl’d by a public / private key pair in asymmetric cryptography."],["Signable","Something that we know how to hash and sign."],["SignableBytes",""],["SigningKey","Trait impl’d by private (secret) keys in asymmetric cryptography."],["SuiAuthoritySignature",""],["SuiPublicKey",""],["SuiSignature",""],["SuiSignatureInner",""],["ToFromBytes","Trait impl’d by concrete types that represent digital cryptographic material (keys). For signatures, we rely on `signature::Signature`, which may be more widely implemented."],["VerifyingKey","Trait impl’d by public keys in asymmetric cryptography."]],"type":[["AccountKeyPair",""],["AccountPrivateKey",""],["AccountPublicKey",""],["AccountSignature",""],["AggregateAuthoritySignature",""],["AuthorityKeyPair",""],["AuthorityPrivateKey",""],["AuthorityPublicKey",""],["AuthoritySignature",""],["AuthorityStrongQuorumSignInfo",""],["AuthorityWeakQuorumSignInfo",""],["NetworkKeyPair",""],["NetworkPrivateKey",""],["NetworkPublicKey",""]]};